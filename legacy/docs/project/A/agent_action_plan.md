---
title: ThinkAlike Agent Action Plan
version: 1.0.0
status: Draft
last_updated: 2025-06-21
maintained_by: Project Team
tags: []
---

# ThinkAlike Agent Action Plan

This document outlines a step-by-step guide for any agent or contributor to systematically clean, harmonize, and build a working MVP of the ThinkAlike project.

## 0. Inventory & Categorization (Pre-Cleanup)

- Rename 0.1 to use existing file index script output
0.1 Generate the canonical file inventory:
```powershell
# PROJECT_FILE_INDEX.md is auto-generated by scripts/generate_file_lists.py
python scripts/generate_file_lists.py
```
- The file `PROJECT_FILE_INDEX.md` now lists every non-excluded file relative to the project root.
- Skip piping to a separate inventory.txt (it will remain empty).

0.2 Categorize each path by type (code, docs, tests, scripts, assets, legacy):
```powershell
# categorized_inventory.yaml is generated by scripts/categorize_inventory.py
python scripts/categorize_inventory.py
```
0.3 Review `categorized_inventory.yaml` and ensure every folder maps into one of:
  - `/src` (application code)
  - `/docs/architecture` (architecture & protocols)
  - `/docs/protocols` (protocol specs)
  - `/docs/ui_components` (UI specs)
  - `/tests` (test code)
  - `/scripts` (automation)
  - `/assets`, `/public`, etc. (static resources)
  - `legacy/` (unmapped, to be archived)

  **Note:** The file `scripts/categorized_inventory.yaml` contains the categorized inventory; open and verify each path is correctly bucketed as above.

0.4 Identify misplaced or duplicated folders (e.g., multiple `framework`, `agent_framework`, `architecture`): manually confirm correct categories.
- Run the report script:
  ```powershell
  python scripts/identify_misplaced_duplicates.py
  ```
- Review `scripts/misplaced_duplicates.md`: decide for each path whether to move it to a canonical location (e.g., move `src\swarm\architecture\*.md` → `docs/architecture/swarm/`) or archive under `legacy/`.

  **Tip:** Use PowerShell to scan the categorized inventory for common duplicate folder names:
  ```powershell
  Select-String -Path .\scripts\categorized_inventory.yaml -Pattern 'framework|agent_framework|architecture'
  ```

0.5 Freeze structure: no file moves outside `legacy/` until Phase 1 begins.
- Ensure the file `.structure_allowed` exists at the project root, listing approved directories; commit this to the repo.
- Validate enforcement locally:
  ```powershell
  python scripts/structure_check.py --fail-on-extras
  ```

**Phase 0 complete.** Proceed to Phase 1.

## 1. Remove Fragmentation & Enforce Canonical Structure

1.1 Run structure check and list all files:
```
python scripts/structure_check.py --report fragmentation_report.txt
python scripts/generate_file_lists.py > all_files.txt
```
1.2 Identify and review duplicates:
```
python scripts/find_duplicates.py --input all_files.txt --output duplicates_report.txt
```
– Open `duplicates_report.txt`, decide on one canonical path per logical concept.
1.2.1 For each candidate file/path identified for removal, search the entire repo for references before archiving or deletion:
```powershell
Select-String -Path .\**\* -Pattern '<relative_or_absolute_path>'
```
– Only archive or delete when no references remain or after updating references to canonical paths.
1.3 Decide on one canonical location for each concept and list them under `canonical_paths.yaml`.
- Populate `canonical_paths.yaml` with mappings from current to desired canonical directories (e.g., `docs/architecture/swarm/`: `docs/architecture/swarm/`).
- Run the consolidation script to reorganize files:
  ```powershell
  python scripts/consolidate_structure.py
  ```
- Review `scripts/consolidate_report.md` to verify all moves before committing.
1.4 Archive or remove non-canonical files:
- Move duplicates into `legacy/` to preserve history.
- Do NOT delete any files at this stage. If a file seems deprecated, mark it with a TODO in `legacy/` for later review rather than removing.
- When moving files to `legacy/`, ensure the complete original content is preserved. Do not replace files with placeholder text or leave empty files.
1.5 Refactor imports and links:
- Populate `canonical_paths.yaml` (already done).
- Run path refactoring script:
  ```powershell
  python scripts/refactor_paths.py
  ```
- Validate that all Markdown links resolve and no broken references:
  ```powershell
  python scripts/link_checker.py --base docs/ --fail-on-broken
  ```
- Install Python test dependencies:
  ```powershell
  python -m pip install -r requirements.txt
  ```
- Ensure Azure SDK dependencies are installed:
  ```powershell
  python -m pip install azure-core
  ```
- Set Python path to include project root for `src` imports:
  ```powershell
  $env:PYTHONPATH = "$PWD"
  ```
- Run tests and verify no import errors:
  ```powershell
  python -m pytest tests/
  npm test
  ```
1.6 Lock down structure with policy and CI:
– Create `.structure_allowed` listing approved root dirs (e.g. `src/`, `docs/`, `scripts/`, etc.).
– Add a pre_commit hook or CI step to enforce no files outside `.structure_allowed`:
```yaml
- name: Enforce Structure
  run: python scripts/structure_check.py --fail-on-extras
```

## 2. Harmonize Documentation & Code References

2.1 Search across code and docs:
```
Select-String -Path .\src\**\*.{ts,py,md} -Pattern '<old_path_or_import>'
```
2.2 Replace outdated paths and imports.
2.3 Validate that every link in markdown resolves: use a link-checker or custom script.

## 3. Lock Structure with CI Gates

3.1 Add a GitHub Actions job in `.github/workflows/ci.yml`:
```yaml
- name: Structure Check
  run: python scripts/structure_check.py --fail-on-extras
```
3.2 Reject any PR that introduces files outside the approved directories.

## 4. Fill Critical Gaps in Priority Order

4.1 Data models & ERD
- Finalize `docs/architecture/data_models.md` and update Prisma schema.
4.2 API & Protocol Documentation
- Complete `docs/api_specs/openapi.json` and generate SDKs.
4.3 Onboarding & Persona Flows
- Implement missing narrative duel UI and backend endpoints.
4.4 Testing & Validation
- Create test coverage scripts and enforce minimum thresholds.
4.5 CI/CD & Observability
- Define pipelines and add health/metrics endpoints.

## 5. Continuous Alignment & Release Readiness

5.1 After each task, update this plan and mark items as done.
5.2 Regenerate file lists and blueprint:
```
python scripts/generate_file_lists.py
```
5.3 Deploy a preview and run smoke tests.
5.4 Update `SYSTEM_BLUEPRINT.md` with completed items and dates.

---

## 6. Additional Governance & Quality Steps

6.1 Enforce code style and formatting:
- Add ESLint/Prettier for TypeScript/JavaScript and Black/Flake8 for Python.
- Run formatters as part of pre_commit or CI:
  ```yaml
  - name: Code Format Check
    run: |
      npm run lint && npm run format:check
      black --check src/ scripts/
  ```

6.2 Automate link and reference validation:
- Integrate markdown link-checker into CI to catch broken links before merge.
- Add a script to detect orphaned files not referenced in code or docs.

6.3 Pre-commit placeholder detection:
- Leverage `.githooks/check_no_placeholder_content.py` to block commits containing TODOs or placeholder text.

6.4 Visualize project structure:
- Generate a tree diagram or site map regularly (e.g., via `scripts/generate_full_project_tree.py`) and commit snapshot to `docs/structure_map.md`.

6.5 Periodic legacy audit:
- Schedule a monthly review of `legacy/` to identify files ready for final deletion or archival.
- Tag files with review dates: embed metadata in file headers, e.g., `<!-- archived:2025-06-20; review:2025-07-20 -->`.

6.6 Enforce unique, domain-specific folder names:
- Rename `src/backend/app/core/` → `src/backend/app/azure_core/` and update imports accordingly.
- Rename generic `src/utils/` → `src/utils/document_utils/` or similar, adjusting all import paths.
- After renaming, run `python scripts/consolidate_structure.py` to capture moves, and `python scripts/refactor_paths.py` to update code references.

*These renames prevent fragmentation and clarifies module responsibilities.*

*These policies ensure a clear and unambiguous directory structure.*

*Keep this plan updated and refer to it for every new task or automation.*
